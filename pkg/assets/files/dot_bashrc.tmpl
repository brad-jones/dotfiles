#!/usr/bin/env bash
# .bashrc - This runs for every non-login interactive shell.

# We do pretty much all the work to configure our shell inside our rc file,
# this means some of the work will be duplicated for any given login session
# everytime a new non-login interactive shell is started. In practical terms I
# can't see this being a major issue.

# Define our path as early as possible
PATH="/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin";
PATH="$HOME/.dart/current/bin:$PATH";
PATH="$HOME/.dotnet:$PATH";
PATH="$HOME/.goenv/bin:$PATH";
PATH="$HOME/.local/bin:$PATH";
PATH="$HOME/.nodenv/bin:$PATH";
PATH="$HOME/.pkenv/bin:$PATH";
PATH="$HOME/.pub-cache/bin:$PATH";
PATH="$HOME/.pyenv/bin:$PATH";
PATH="$HOME/.rbenv/bin:$PATH";
PATH="$HOME/.tfenv/bin:$PATH";
PATH="$HOME/.tfenv/bin:$PATH";
PATH="$HOME/.dprint/bin:$PATH";
PATH="$HOME/.asdf/installs/deno/1.9.2/bin:$PATH";
{{ if .Runtime.IsWSL -}}
PATH="/mnt/c/Windows/System32:$PATH";
PATH="/mnt/c/Windows/System32/WindowsPowerShell/v1.0:$PATH";
PATH="/mnt/c/Program Files/Mozilla Firefox:$PATH";
PATH="/mnt/c/Program Files/Google/Chrome/Application:$PATH";
PATH="/mnt/c/Users/$USER/.scoop/apps/vscode/current/bin:$PATH";
{{ end }}

# Source global definitions
[ -f /etc/bashrc ] && . /etc/bashrc;

# Use VsCode as our editor for all the things
export EDITOR="code -w";

# Setup the ssh-agent
export SSH_AUTH_SOCK="$HOME/.ssh/agent.sock";

# Standardise UID & GID, UID is normally set but GID is not.
# So we just do both here which makes writting scripts easier.
export UID="$(id -u)" &> /dev/null || true;
export GID="$(id -g)" &> /dev/null || true;

# see: https://dprint.dev/install/
export DPRINT_INSTALL="$HOME/.dprint";

# Tell goenv where to install go, personally I prefer all my tools and
# config to be hidden (ie: start with a dot) and all my actual data
# folders/files to be unhidden.
export GOENV_GOPATH_PREFIX="$HOME/.go";

# Configure aws-vault to use gopass to store our idenities
export AWS_VAULT_BACKEND="pass";
export AWS_VAULT_PASS_CMD="gopass";
export AWS_VAULT_PASS_PREFIX="aws-vault";
export AWS_VAULT_PASS_PASSWORD_STORE_DIR="$HOME/.password-store";

# Setup some bash auto completion
complete -C "$HOME/.local/bin/aws_completer" aws;
eval "$(aws-vault --completion-script-bash)";
eval "$(gopass completion bash)";
eval "$(kubectl completion bash)";

# Setup all our tool version managers
. "$HOME/.asdf/asdf.sh";
. "$HOME/.asdf/completions/asdf.bash";
. "$HOME/.sdkman/bin/sdkman-init.sh";
eval "$(nodenv init -)";
export PYENV_ROOT="$HOME/.pyenv";
eval "$(pyenv init --path)";
eval "$(pyenv init -)";
eval "$(rbenv init -)";
eval "$(goenv init -)";
PATH="$PATH:$GOROOT/bin";
PATH="$PATH:$GOPATH/bin";

# Setup kubectl
KUBECONFIG="$HOME/.kube/config.yml";
KUBECONFIG="$KUBECONFIG:$HOME/.kube/xero/clusters.yml";
KUBECONFIG="$KUBECONFIG:$HOME/.kube/xero/users.yml";
KUBECONFIG="$KUBECONFIG:$HOME/.kube/xero/xero-payroll-xfectwo.yml";
export KUBECONFIG;

{{ if .Runtime.IsWSL -}}
# Tell Podman where to find our auth file
export REGISTRY_AUTH_FILE="$HOME/.config/containers/auth.json";

# Without systemd, the $XDG_RUNTIME_DIR is not available for podman (& other
# systemd`y things) to use for temporary files. So we create it here.
if [[ -z "$XDG_RUNTIME_DIR" ]]; then
  export XDG_RUNTIME_DIR=/run/user/$UID
  if [[ ! -d "$XDG_RUNTIME_DIR" ]]; then
    export XDG_RUNTIME_DIR=/tmp/$USER-runtime
    if [[ ! -d "$XDG_RUNTIME_DIR" ]]; then
      mkdir -m 0700 "$XDG_RUNTIME_DIR"
    fi
  fi
fi
{{ end -}}
